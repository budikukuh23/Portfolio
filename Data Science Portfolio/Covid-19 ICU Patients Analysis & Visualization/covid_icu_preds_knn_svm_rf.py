# -*- coding: utf-8 -*-
"""Covid ICU Preds knn svm rf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i0Yo2fFou0MNqd7WXHefv4OdFHjHa497
"""

import pandas as pd
import numpy as np
import warnings

from sklearn.preprocessing import StandardScaler
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.ensemble import AdaBoostClassifier
from sklearn.tree import DecisionTreeClassifier
from xgboost import XGBClassifier

pd.set_option('display.max_columns', None)
warnings.filterwarnings('ignore')

''' reading data '''
df = pd.read_csv('https://firebasestorage.googleapis.com/v0/b/budi-23.appspot.com/o/dataset%2FCovid-19%20ICU%20Patients%20Analysis%20%26%20Visualization%2Fcovid.csv?alt=media&token=b216a797-2633-4e81-8bf1-4dea6ce290ab', parse_dates=[3, 4])

''' displaying first 5 rows of data '''
df.head()

''' shape of data '''
df.shape

''' checking null valeus '''
df.isnull().sum()

''' dropping unwanted rows '''

df.drop(['id','patient_type','pregnancy','contact_other_covid','other_disease'],inplace=True,axis=1)

''' creating new column '''

df['new_column'] = (df['entry_date'] - df['date_symptoms']).dt.days
df['dead']='1'
df.loc[df['date_died'] == '9999-99-99','dead']='0'

''' dropping columns '''
df.drop(['entry_date','date_symptoms','date_died'],inplace=True,axis=1)

''' changing datatype '''
df = df.astype('int8')

''' dropping null values '''

df = df.loc[(df['sex'] <= 2) & (df['intubed'] <= 2) & (df['pneumonia'] <= 2) & (df['diabetes'] <= 2) & 
            (df['copd'] <= 2) & (df['asthma'] <= 2) & (df['inmsupr'] <= 2) & (df['hypertension'] <= 2) & 
            (df['cardiovascular'] <= 2) & (df['obesity'] <= 2) & (df['renal_chronic'] <= 2) & (df['tobacco'] <= 2) &
            (df['covid_res'] <= 2) & (df['dead'] <= 2) & (df['icu'] <= 2) & (df['new_column'] >= 0), 
            ['sex','age','inmsupr','pneumonia','diabetes','asthma','copd','hypertension','cardiovascular',
             'renal_chronic','obesity','tobacco','new_column','covid_res','intubed','icu','dead']]

''' changing values of NO from  2 to 0'''

df.loc[df['sex']==2,'sex']=0

df.loc[df['inmsupr']==2,'inmsupr']=0

df.loc[df['pneumonia']==2,'pneumonia']=0

df.loc[df['diabetes']==2,'diabetes']=0

df.loc[df['asthma']==2,'asthma']=0

df.loc[df['copd']==2,'copd']=0

df.loc[df['hypertension']==2,'hypertension']=0

df.loc[df['cardiovascular']==2,'cardiovascular']=0

df.loc[df['renal_chronic']==2,'renal_chronic']=0

df.loc[df['obesity']==2,'obesity']=0

df.loc[df['tobacco']==2,'tobacco']=0

df.loc[df['intubed']==2,'intubed']=0

df.loc[df['icu']==2,'icu']=0

df.loc[df['covid_res']==2,'covid_res']=0

''' new df looks like '''
df.head()

''' considering only patients who are tested positive to covid '''
df = df.loc[df['covid_res'] == 1, ['sex','age','inmsupr','pneumonia','diabetes','asthma','copd','hypertension',
                                   'cardiovascular','renal_chronic','obesity','tobacco','new_column',
                                   'covid_res','intubed','icu','dead']]

''' independent and dependent features '''
X = df.drop(['icu','covid_res','dead','intubed'], axis=1)
y = df['icu']

''' value counts of y '''
y.value_counts()

''' SMOTE to overcome the situation of imbalanced data '''
smote = SMOTE(random_state=42)

''' fit on X and y'''
X_smote, y_smote = smote.fit_resample(X, y)

''' again value counts of y '''
y_smote.value_counts()

''' train test split '''
X_train, X_test, y_train, y_test = train_test_split(X_smote, y_smote, test_size=0.25, random_state=0)

print('X_train shape: ', X_train.shape)
print('X_test shape: ', X_test.shape)

def evaluation_fun():
    print("train Accuracy = {}".format(accuracy_score(y_train, model.predict(X_train))))
    print("test Accuracy = {}".format(accuracy_score(y_test, results)))
    print("Confusion Matrix")
    print(confusion_matrix(y_test, results))
    print("Classification Report")
    print(classification_report(y_test, results))

''' Random Forest '''
model = RandomForestClassifier()

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

''' results of rf '''
evaluation_fun()

''' xgboost '''
model = XGBClassifier()

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()

''' KNN without hyperparameter tunning '''
model = KNeighborsClassifier()

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()

''' ADA BOOST without hyper parameter tunning'''
model = AdaBoostClassifier()

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()

''' Gradient Boost with hyperparameter tunnig '''
model = GradientBoostingClassifier(max_features='auto', loss='deviance',learning_rate=0.3, 
                                   max_depth=8,min_samples_leaf=3,min_samples_split=0.1, n_estimators=400, subsample=0.4)

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()

''' Gradient Boosting without hyper parameter tunning '''
model = GradientBoostingClassifier()

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()

''' KNN with hyper parameter tunning '''
model = KNeighborsClassifier(n_neighbors=5,weights='distance',p=1,metric='minkowski')

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()

''' ADA Boost with hyper parameter tunning '''
model = AdaBoostClassifier(n_estimators= 9000)

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()

''' SVM '''
model = SVC()

''' fit on data '''
model.fit(X_train, y_train)

''' prediction '''
results = model.predict(X_test)

evaluation_fun()